/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/models/scene_animation.glb -o ./components/WebGL/Model/Model.tsx -r public --types --draco 
*/
import { useGLTF, useAnimations } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import React, { useEffect, useRef, useMemo, useCallback } from 'react';
import { useRecoilValue } from 'recoil';
import * as THREE from 'three';
import { GLTF } from 'three-stdlib';

import suitcaseFragment from '@/shaders/suitcase/fragment-suitcase.glsl';
import suitcaseVertex from '@/shaders/suitcase/vertex-suitcase.glsl';
import { isScrollEndAtom } from '@/store/scrollAtom';
import { AnimationControls } from '@/types/animation';

import { ExtendedMaterial } from './ExtendedMaterial';

type GLTFResult = GLTF & {
  nodes: {
    body: THREE.SkinnedMesh;
    bottoms: THREE.SkinnedMesh;
    cap: THREE.SkinnedMesh;
    comtac: THREE.SkinnedMesh;
    comtac_yeahpad: THREE.SkinnedMesh;
    glass: THREE.SkinnedMesh;
    goggle_belt: THREE.SkinnedMesh;
    goggle_frame: THREE.SkinnedMesh;
    Head_1: THREE.SkinnedMesh;
    shoes: THREE.SkinnedMesh;
    tops: THREE.SkinnedMesh;
    suitcase: THREE.Mesh;
    Root: THREE.Bone;
  };
  materials: object;
  animations: GLTFAction[];
};

type ActionName = 'ArmatureAction';

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GroupProps = JSX.IntrinsicElements['group'];

interface ModelProps extends GroupProps {
  textures?: {
    characterTexture: THREE.Texture;
    suitcaseTexture: THREE.Texture;
  };
  animationControls: AnimationControls;
}

export const Model = ({ textures, animationControls, ...props }: ModelProps) => {
  // console.log('re rendered : model' + performance.now());

  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF('/models/scene_animation_02.glb') as GLTFResult;
  const { actions } = useAnimations(animations, group);
  const suitcaseRef = useRef<THREE.Mesh>(null);
  const suitcaseTargetPosition = useRef<THREE.Vector3>(new THREE.Vector3());
  const isScrollEnd = useRecoilValue(isScrollEndAtom);

  //キャラクター用の拡張マテリアルへの参照
  const extendedMaterials = useRef<{ [key: string]: ExtendedMaterial }>({});

  //キャラクター用のマテリアル
  useEffect(() => {
    Object.entries(materials).forEach(([name, material]) => {
      const extendedMaterial = new ExtendedMaterial();
      extendedMaterial.copy(material as THREE.Material);

      extendedMaterials.current[name] = extendedMaterial;

      // console.log('name : ', name, '\n', 'extended material : ', extendedMaterial);
    });
  }, [materials]);

  //キャラクターアニメーション
  useEffect(() => {
    const action = actions?.['ArmatureAction'];

    if (action) {
      action.reset().fadeIn(0.5).play();
      action.clampWhenFinished = true;
      action.loop = THREE.LoopRepeat;
    }

    return () => {
      if (action) {
        action.fadeOut(0.5);
      }
    };
  }, [actions]);

  //スーツケース用のマテリアル
  const suitcaseMaterial = useMemo(() => {
    if (!textures) return;

    const { suitcaseTexture } = textures;

    const shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTexture: {
          value: suitcaseTexture,
        },
        uLightPosition: {
          value: new THREE.Vector3(0.0, 1.0, 1.0),
        },
        uFrasnelBias: {
          value: 2.0,
        },
        uIsScrollEnd: {
          value: 0,
        },
        uResolution: {
          value: new THREE.Vector2(
            window.innerWidth * devicePixelRatio,
            window.innerHeight * devicePixelRatio
          ),
        },
        // uTextureResolution: {
        //   value: null,
        // },
        uTime: {
          value: 0,
        },
      },
      vertexShader: suitcaseVertex,
      fragmentShader: suitcaseFragment,
    });

    return shaderMaterial;
  }, [textures]);

  //isScrollEndが変更されたときのマテリアルの更新
  useEffect(() => {
    if (suitcaseMaterial) {
      suitcaseMaterial.uniforms.uIsScrollEnd.value = isScrollEnd ? 1 : 0;
    }
  }, [isScrollEnd, suitcaseMaterial]);

  //リサイズ時の更新
  useEffect(() => {
    const handleResize = () => {
      if (!suitcaseMaterial) return;
      suitcaseMaterial.uniforms.uResolution.value.set(
        window.innerWidth * devicePixelRatio,
        window.innerHeight * devicePixelRatio
      );
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, [suitcaseMaterial]);

  //スーツケースの位置算出につかう
  const calculateSuitcasePosition = useCallback((width: number): [number, number, number] => {
    const BREAKPOINTS = {
      mobile: 360,
      desktop: 1440,
    };

    const POSITIONS = {
      // mobile: [-0.6, 3.6, -1.5],
      mobile: [-0.6, 3.5, -2.05],
      desktop: [-0.6, 3.2, 1.05],
    };

    //画面幅に応じて、0 - 1の範囲をとる
    const moveRange = Math.max(
      0,
      Math.min(1, (width - BREAKPOINTS.mobile) / (BREAKPOINTS.desktop - BREAKPOINTS.mobile))
    );

    //0のときはmobileの位置、1のときはdesktopの位置をとるようになる
    return [
      THREE.MathUtils.lerp(POSITIONS.mobile[0], POSITIONS.desktop[0], moveRange),
      THREE.MathUtils.lerp(POSITIONS.mobile[1], POSITIONS.desktop[1], moveRange),
      THREE.MathUtils.lerp(POSITIONS.mobile[2], POSITIONS.desktop[2], moveRange),
    ];
  }, []);

  useFrame((state, delta) => {
    const lerpFactor = 1.0 - Math.pow(0.05, delta);

    const originalSuitcasePosition = {
      x: 0.551,
      y: 0.282,
      z: -4.68,
    };

    if (suitcaseRef.current) {
      const shaderMaterial = suitcaseRef.current.material as THREE.ShaderMaterial;

      shaderMaterial.uniforms.uTime.value = delta;

      if (isScrollEnd) {
        //----------スーツケースの位置決定----------
        suitcaseRef.current.rotation.x = (Math.PI * 1) / 16;
        suitcaseRef.current.rotation.y += (delta * Math.PI * 1) / 16;
        suitcaseRef.current.rotation.z = (Math.PI * 1) / 8;

        // 画面幅に基づいて位置を計算
        const calculatedPosition = calculateSuitcasePosition(window.innerWidth);

        suitcaseTargetPosition.current.x = calculatedPosition[0] + originalSuitcasePosition.x;
        suitcaseTargetPosition.current.y = calculatedPosition[1] + originalSuitcasePosition.y;
        suitcaseTargetPosition.current.z = calculatedPosition[2] + originalSuitcasePosition.z;

        //----------スーツケースのuniforms設定----------
      } else {
        suitcaseTargetPosition.current.x = originalSuitcasePosition.x;
        suitcaseTargetPosition.current.y = originalSuitcasePosition.y;
        suitcaseTargetPosition.current.z = originalSuitcasePosition.z;

        suitcaseRef.current.rotation.x = 0;
        suitcaseRef.current.rotation.y = 0;
        suitcaseRef.current.rotation.z = 0;
      }
    }

    suitcaseRef.current?.position.lerp(suitcaseTargetPosition.current, lerpFactor);
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature">
          <primitive object={nodes.Root} />
          {Object.entries(nodes).map(([name, node]) => {
            const originalMaterial = (node as THREE.Mesh).material as THREE.Material;

            let extendedMaterial;

            if (originalMaterial) {
              extendedMaterial = extendedMaterials.current[originalMaterial.name];
            }

            if (node instanceof THREE.SkinnedMesh) {
              return (
                <skinnedMesh
                  key={name}
                  name={name}
                  geometry={node.geometry}
                  material={extendedMaterial || node.material}
                  skeleton={node.skeleton}
                />
              );
            }
            return null;
          })}
        </group>
        <mesh
          ref={suitcaseRef}
          name="suitcase"
          geometry={nodes.suitcase.geometry}
          material={suitcaseMaterial}
          // position={[0.551, 0.282, -4.68]}//blenderにて設定された初期位置
        />
      </group>
    </group>
  );
};

useGLTF.preload('/models/scene_animation_02.glb');

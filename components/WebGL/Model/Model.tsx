/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 public/models/scene_animation.glb -o ./components/WebGL/Model/Model.tsx -r public --types --draco 
*/

import * as THREE from 'three';
import React, { useEffect, useRef, useMemo } from 'react';
import { useGLTF, useAnimations } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { AnimationControls } from '@/types/animation';
import { ExtendedMaterial } from './ExtendedMaterial';

import suitcaseFragment from '@/shaders/suitcase/fragment-suitcase.glsl';
import suitcaseVertex from '@/shaders/suitcase/vertex-suitcase.glsl';

type GLTFResult = GLTF & {
  nodes: {
    body: THREE.SkinnedMesh;
    bottoms: THREE.SkinnedMesh;
    cap: THREE.SkinnedMesh;
    comtac: THREE.SkinnedMesh;
    comtac_yeahpad: THREE.SkinnedMesh;
    glass: THREE.SkinnedMesh;
    goggle_belt: THREE.SkinnedMesh;
    goggle_frame: THREE.SkinnedMesh;
    Head_1: THREE.SkinnedMesh;
    shoes: THREE.SkinnedMesh;
    tops: THREE.SkinnedMesh;
    suitcase: THREE.Mesh;
    Root: THREE.Bone;
  };
  materials: {};
  animations: GLTFAction[];
};

type ActionName = 'ArmatureAction';

interface GLTFAction extends THREE.AnimationClip {
  name: ActionName;
}

type GroupProps = JSX.IntrinsicElements['group'];

interface ModelProps extends GroupProps {
  textures?: {
    characterTexture: THREE.Texture;
    suitcaseTexture: THREE.Texture;
  };
  animationControls: AnimationControls;
}

export const Model = ({ textures, animationControls, ...props }: ModelProps) => {
  const group = useRef<THREE.Group>(null);
  const { nodes, materials, animations } = useGLTF('/models/scene_animation.glb') as GLTFResult;
  const { actions } = useAnimations(animations, group);

  //キャラクター用の拡張マテリアルへの参照
  const extendedMaterials = useRef<{ [key: string]: ExtendedMaterial }>({});

  //キャラクター用のマテリアル
  useEffect(() => {
    Object.entries(materials).forEach(([name, material]) => {
      const extendedMaterial = new ExtendedMaterial();
      extendedMaterial.copy(material as THREE.Material);

      extendedMaterials.current[name] = extendedMaterial;

      // console.log('name : ', name, '\n', 'extended material : ', extendedMaterial);
    });
  }, [materials]);

  //アニメーション
  useEffect(() => {
    const action = actions?.['ArmatureAction'];

    if (action) {
      action.reset().fadeIn(0.5).play();
      action.clampWhenFinished = true;
      action.loop = THREE.LoopRepeat;
    }

    return () => {
      if (action) {
        action.fadeOut(0.5);
      }
    };
  }, [actions]);

  //スーツケース
  const suitcaseMaterial = useMemo(() => {
    if (!textures) return;

    const { suitcaseTexture } = textures;

    const shaderMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTexture: {
          value: suitcaseTexture,
        },
        // uResolution: {
        //   value: null,
        // },
        // uTextureResolution: {
        //   value: null,
        // },
        // uTime: {
        //   value: 0,
        // },
      },
      vertexShader: suitcaseVertex,
      fragmentShader: suitcaseFragment,
    });

    // const meshBasicMaterial = new THREE.MeshBasicMaterial({
    //   map: suitcaseTexture,
    // });

    return shaderMaterial;
  }, [textures]);

  return (
    <group castShadow ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature">
          <primitive object={nodes.Root} />
          {Object.entries(nodes).map(([name, node]) => {
            const originalMaterial = (node as THREE.Mesh).material as THREE.Material;

            let extendedMaterial;

            if (originalMaterial) {
              extendedMaterial = extendedMaterials.current[originalMaterial.name];
            }

            if (node instanceof THREE.SkinnedMesh) {
              return (
                <skinnedMesh
                  key={name}
                  name={name}
                  geometry={node.geometry}
                  material={extendedMaterial || node.material}
                  skeleton={node.skeleton}
                />
              );
            }
            return null;
          })}
        </group>
        <mesh name="suitcase" geometry={nodes.suitcase.geometry} material={suitcaseMaterial} />
      </group>
    </group>
  );
};

useGLTF.preload('/models/scene_animation.glb');
